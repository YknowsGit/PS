// [빡구현 100선] - 주사위 쌓기
package Random._2025.Random1Day8M;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Q2116 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());
        int[][] dice = new int[n][6];
        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            for (int j = 0; j < 6; j++) {
                dice[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        int[] op = {5, 3, 4, 1, 2, 0};
        // 1 2 3 4 5 6
        // 대칭이 되는 인덱스
        int result = 0;
        for (int i = 0; i < 6; i++) {
            // 첫번째 다이스 경우의 수 6가지
            int underIndex = i;
            int underNum = dice[0][i];

            int upperIndex = op[i];
            int upperNum = dice[0][upperIndex];
            int nextUnder = upperNum;

            int sum = 0;
            int sideMax = 0;
            for (int j = 0; j < 6; j++) {
                int sideIndex = j;

                if (j == underIndex) continue;
                if (j == upperIndex) continue;

                int sideNum = dice[0][sideIndex];
                sideMax = Math.max(sideMax, sideNum);
            }

            sum += sideMax;

            // nextUnder 를 가지고 남은 다이스 고정 후 계산
            for (int j = 1; j < n; j++) {
                int nextIndex = j;
                int nextUnderIndex = 0;
                for (int k = 0; k < 6; k++) {
                    if (dice[nextIndex][k] == nextUnder) {
                        nextUnderIndex = k;
                        break;
                    }
                }
                int nextUnderNum = dice[nextIndex][nextUnderIndex];

                int nextUpperIndex = op[nextUnderIndex];
                int nextUpperNum = dice[j][nextUpperIndex];
                nextUnder = nextUpperNum;

                int nextSideMax = 0;
                for (int k = 0; k < 6; k++) {
                    int nextSideIndex = k;

                    if (k == nextUnderIndex) continue;
                    if (k == nextUpperIndex) continue;

                    int nextSideNum = dice[j][nextSideIndex];
                    nextSideMax = Math.max(nextSideMax, nextSideNum);
                }

                sum += nextSideMax;
            }

            result = Math.max(result, sum);
        }

        System.out.println(result);
    }
}
/*
서로 붙어있는 두 개의 주사위에서
아래에 있는 주사위의 윗면에 적혀있는 숫자는
위에 있는 주사위의 아랫면에 적혀있는 숫자와 같아야 한다.

=> 1번 주사위 윗면의 숫자는 2번 주사위 아랫면의 숫자와 같고,
=> 2번 주사위 윗면의 숫자는 3번 주사위 아랫면의 숫자와 같다.
=> 단, 1번 주사위는 마음대로 놓을 수 있다.

각 주사위를 위 아래를 고정한 채
옆으로 90도, 180도, 270도 돌릴 수 있음
한 옆면의 숫자의 합의 최대값을 구해라.
 */
/*
그림 그리면서 알게 된 사실
1.
한 쌍 (대칭)
A <-> F, B <-> D, C <-> E
인덱스로 변환하면.
0 <-> 5, 1 <-> 3, 2 <-> 4

2.
i 번째 주사위 윗 면(A) 와
i + 1 번째 주사위 아랫 면(F) 와 같다.
윗면 == 다음 주사위 아랫면
옆면 중 최댓값을 고른다.

=> 주사위를 순서대로 보면서, 윗면 숫자에 따라 다음 주사위 아랫면이 정해진다
=> 이걸 기준으로 매 주사위를 처리한다.
=> 구현: 윗면 숫자 -> 다음 주사위 아랫면 숫자로 넘기는 과정

3.
첫번째 주사위의 위치는 맘대로 두어도 됨...
=> 따라서 6가지 시작점
=> 0~ 5번 면을 아랫면으로 둘 수 있음.
 */
