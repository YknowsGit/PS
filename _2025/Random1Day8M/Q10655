// [빡구현 100선] - 마라톤 1
package Random._2025.Random1Day8M;

import java.util.*;
import java.io.*;

public class Q10655 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());

        int[] x = new int[n];
        int[] y = new int[n];

        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            x[i] = Integer.parseInt(st.nextToken());
            y[i] = Integer.parseInt(st.nextToken());
        }

        int max = Integer.MIN_VALUE;
        int maxDist = 0;
        int[] dist = new int[n-1];
        int[] passDist = new int[n-1];
        int total = 0;
        for (int i = 1; i <= n - 1; i++) { // i = 1, 2, 3 => 3번
            dist[i-1] = Math.abs(x[i-1] - x[i]) + Math.abs(y[i-1] - y[i]);
            total += dist[i-1];
        }

        for (int i = 1; i < n - 1; i++) { // i = 1, 2 => 2번
            passDist[i-1] = Math.abs(x[i-1] - x[i+1]) + Math.abs(y[i-1] - y[i+1]);

            maxDist = (dist[i-1] + dist[i]) - passDist[i-1];
            max = Math.max(max, maxDist);
        }

        System.out.print(total - max);
    }
}
/*
1. ArrayIndexOutOfBoundsException 오류 방지 (i-1, i+1 접근)

접근 대상 기준으로 반복문 범위 설계할 것
=> 꼭 "i 부터 접근" 하려 하지 말고, 접근 대상 기준 설계
=> 필요한 인덱스가 i-1, i, i+1이면, 그 중 가장 작은 인덱스 부터 계산 for문 안에서

sol:
내가 어떤 인덱스를 쓸 거지? -> i-1, i, i+1
그럼 i는 최소 1이상 이고 , i+1 < length 여야 하겠네?
따라서 반복문 범위는 i = 1부터 n-2로 잡는다.
 */
/*
2. 중심 인덱스(i)를 기준으로 하지 말고, 양옆(i-1)에서 접근

(i-1 -> i) + (i -> i+1)이면, 중심 i 는 같지만
진짜 필요한 건 i-1 부터 시작하는 두 구간

sol:
반복문에서 i 가 아니라 i-1에 먼저 접근해서 구성!!!
그래야 인덱스 흐름이 자연스럽고 경계도 안전

 */
